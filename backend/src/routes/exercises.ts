import { FastifyPluginAsync, FastifyRequest, FastifyReply } from 'fastify';
import { exercises, modules, NewExercise, NewModule } from '../db/schema';
import { eq, and, desc, asc } from 'drizzle-orm';
import { exerciseSchemas } from '../schemas/exercise.schema';

const exercisesRoutes: FastifyPluginAsync = async (fastify) => {
  
  // ==========================================
  // MODULE MANAGEMENT ROUTES
  // ==========================================
  
  // Create pedagogical module
  fastify.post('/modules', {
    schema: exerciseSchemas.createModule,
    preHandler: [fastify.authenticate, fastify.requireAdmin], // Add admin check
    handler: async (request: FastifyRequest<{
      Body: {
        titre: string;
        description: string;
        niveau: 'CP' | 'CE1' | 'CE2' | 'CM1' | 'CM2';
        matiere: 'MATHEMATIQUES' | 'FRANCAIS' | 'SCIENCES' | 'HISTOIRE_GEOGRAPHIE' | 'ANGLAIS';
        periode: 'P1' | 'P2' | 'P3' | 'P4' | 'P5';
        ordre?: number;
        competenceCode?: string; // CP.FR.L1.1 format
        metadata?: Record<string, any>;
      }
    }>, reply: FastifyReply) => {
      try {
        const { competenceCode, ...moduleData } = request.body;
        
        // Add competence mapping to metadata
        const metadata = {
          ...moduleData.metadata,
          competenceCode: competenceCode,
          autoGenerated: true,
          createdBy: request.user.id,
          cp2025Compliant: true
        };

        const newModule: NewModule = {
          ...moduleData,
          metadata,
          ordre: moduleData.ordre || 1
        };

        const [createdModule] = await fastify.db
          .insert(modules)
          .values(newModule)
          .returning();

        // Clear relevant caches
        await fastify.cache.del([
          'modules:*',
          `hierarchy:${moduleData.niveau}:*`
        ]);

        return reply.status(201).send({
          success: true,
          data: createdModule,
          message: 'Module créé avec succès'
        });
      } catch (error) {
        fastify.log.error('Create module error:', error);
        return reply.status(500).send({
          success: false,
          error: {
            message: 'Erreur lors de la création du module',
            code: 'CREATE_MODULE_ERROR'
          }
        });
      }
    }
  });

  // ==========================================
  // EXERCISE MANAGEMENT ROUTES
  // ==========================================

  // Create exercise with CP 2025 competence mapping
  fastify.post('/', {
    schema: exerciseSchemas.createExercise,
    preHandler: [fastify.authenticate, fastify.requireAdmin],
    handler: async (request: FastifyRequest<{
      Body: {
        titre: string;
        consigne: string;
        type: 'QCM' | 'CALCUL' | 'TEXTE_LIBRE' | 'DRAG_DROP' | 'CONJUGAISON' | 'LECTURE' | 'GEOMETRIE' | 'PROBLEME';
        difficulte: 'decouverte' | 'entrainement' | 'consolidation' | 'approfondissement';
        moduleId: number;
        competenceCode: string; // CP.FR.L1.1 format
        configuration: {
          // Exercise-specific configuration based on type
          question?: string;
          choix?: string[];
          bonneReponse?: string | number;
          solution?: any;
          targetWords?: string[];
          dragItems?: Array<{ id: string; content: string; category?: string }>;
          dropZones?: Array<{ id: string; label: string; accepts?: string[] }>;
          // Add more fields as needed
        };
        pointsReussite?: number;
        dureeEstimee?: number;
        ordre?: number;
        metadata?: Record<string, any>;
      }
    }>, reply: FastifyReply) => {
      try {
        const { competenceCode, configuration, ...exerciseData } = request.body;
        
        // Validate competence code format (CP.FR.L1.1)
        const competenceRegex = /^(CP|CE1|CE2|CM1|CM2)\.(FR|MA)\.[A-Z]+\d+\.\d+$/;
        if (!competenceRegex.test(competenceCode)) {
          return reply.status(400).send({
            success: false,
            error: {
              message: 'Format de code compétence invalide. Attendu: CP.FR.L1.1',
              code: 'INVALID_COMPETENCE_CODE'
            }
          });
        }

        // Verify module exists
        const module = await fastify.db
          .select()
          .from(modules)
          .where(eq(modules.id, exerciseData.moduleId))
          .limit(1);

        if (!module.length) {
          return reply.status(404).send({
            success: false,
            error: {
              message: 'Module non trouvé',
              code: 'MODULE_NOT_FOUND'
            }
          });
        }

        // Enhanced metadata with CP 2025 mapping
        const metadata = {
          ...exerciseData.metadata,
          competenceCode,
          cp2025Compliant: true,
          createdBy: request.user.id,
          validationStatus: 'pending',
          autoGenerated: false,
          difficultyMapping: {
            // Map to CP difficulty progression
            decouverte: 'Première approche',
            entrainement: 'Pratique guidée', 
            consolidation: 'Maîtrise attendue',
            approfondissement: 'Expertise'
          }[exerciseData.difficulte]
        };

        // Validate configuration based on exercise type
        const validatedConfig = await validateExerciseConfiguration(
          exerciseData.type, 
          configuration
        );

        const newExercise: NewExercise = {
          ...exerciseData,
          configuration: validatedConfig,
          metadata,
          pointsReussite: exerciseData.pointsReussite || 10,
          dureeEstimee: exerciseData.dureeEstimee || 5,
          ordre: exerciseData.ordre || 1
        };

        const [createdExercise] = await fastify.db
          .insert(exercises)
          .values(newExercise)
          .returning();

        // Clear relevant caches
        await fastify.cache.del([
          'exercises:*',
          `module:${exerciseData.moduleId}:exercises`,
          'recommendations:*'
        ]);

        return reply.status(201).send({
          success: true,
          data: createdExercise,
          message: 'Exercice créé avec succès'
        });

      } catch (error) {
        fastify.log.error('Create exercise error:', error);
        return reply.status(500).send({
          success: false,
          error: {
            message: 'Erreur lors de la création de l\'exercice',
            code: 'CREATE_EXERCISE_ERROR'
          }
        });
      }
    }
  });

  // Bulk create exercises from CP 2025 competences
  fastify.post('/bulk-generate', {
    schema: exerciseSchemas.bulkGenerate,
    preHandler: [fastify.authenticate, fastify.requireAdmin],
    handler: async (request: FastifyRequest<{
      Body: {
        competenceCodes: string[]; // Array of CP.FR.L1.1 format codes
        moduleId: number;
        baseConfiguration: Record<string, any>;
        generateVariations?: boolean;
      }
    }>, reply: FastifyReply) => {
      try {
        const { competenceCodes, moduleId, baseConfiguration, generateVariations = true } = request.body;
        
        const createdExercises = [];
        
        for (const competenceCode of competenceCodes) {
          // Parse competence code
          const [niveau, matiere, domaine, competence] = competenceCode.split('.');
          
          // Generate exercise variants based on competence
          const exerciseTemplates = await generateExercisesForCompetence(
            competenceCode,
            baseConfiguration,
            generateVariations
          );
          
          for (const template of exerciseTemplates) {
            const newExercise: NewExercise = {
              titre: template.titre,
              consigne: template.consigne,
              type: template.type,
              difficulte: template.difficulte,
              moduleId,
              configuration: template.configuration,
              metadata: {
                competenceCode,
                autoGenerated: true,
                generationTimestamp: new Date().toISOString(),
                cp2025Compliant: true
              },
              pointsReussite: template.pointsReussite || 10,
              dureeEstimee: template.dureeEstimee || 5,
              ordre: template.ordre || 1
            };

            const [created] = await fastify.db
              .insert(exercises)
              .values(newExercise)
              .returning();
              
            createdExercises.push(created);
          }
        }

        // Clear caches
        await fastify.cache.del(['exercises:*', 'recommendations:*']);

        return reply.status(201).send({
          success: true,
          data: {
            created: createdExercises.length,
            exercises: createdExercises
          },
          message: `${createdExercises.length} exercices générés avec succès`
        });

      } catch (error) {
        fastify.log.error('Bulk generate error:', error);
        return reply.status(500).send({
          success: false,
          error: {
            message: 'Erreur lors de la génération en masse',
            code: 'BULK_GENERATE_ERROR'
          }
        });
      }
    }
  });

  // Get exercises by competence code
  fastify.get('/by-competence/:code', {
    schema: exerciseSchemas.getByCompetence,
    handler: async (request: FastifyRequest<{
      Params: { code: string };
      Querystring: { 
        limit?: string; 
        offset?: string; 
        difficulte?: string;
      };
    }>, reply: FastifyReply) => {
      try {
        const { code } = request.params;
        const limit = Math.min(parseInt(request.query.limit || '20'), 100);
        const offset = parseInt(request.query.offset || '0');
        const difficulte = request.query.difficulte;

        // Build query
        let query = fastify.db
          .select({
            id: exercises.id,
            titre: exercises.titre,
            consigne: exercises.consigne,
            type: exercises.type,
            difficulte: exercises.difficulte,
            pointsReussite: exercises.pointsReussite,
            dureeEstimee: exercises.dureeEstimee,
            ordre: exercises.ordre,
            configuration: exercises.configuration,
            createdAt: exercises.createdAt,
            moduleTitle: modules.titre,
            moduleMatiere: modules.matiere
          })
          .from(exercises)
          .leftJoin(modules, eq(exercises.moduleId, modules.id))
          .where(eq(exercises.metadata, { competenceCode: code }))
          .orderBy(asc(exercises.ordre), asc(exercises.id))
          .limit(limit)
          .offset(offset);

        if (difficulte) {
          query = query.where(
            and(
              eq(exercises.metadata, { competenceCode: code }),
              eq(exercises.difficulte, difficulte as any)
            )
          );
        }

        const results = await query;

        return reply.send({
          success: true,
          data: {
            exercises: results,
            pagination: {
              limit,
              offset,
              total: results.length, // TODO: Add proper count
              hasMore: results.length === limit
            }
          },
          message: `Exercices pour la compétence ${code}`
        });

      } catch (error) {
        fastify.log.error('Get by competence error:', error);
        return reply.status(500).send({
          success: false,
          error: {
            message: 'Erreur lors de la récupération des exercices',
            code: 'GET_BY_COMPETENCE_ERROR'
          }
        });
      }
    }
  });

  // Update exercise
  fastify.put('/:id', {
    schema: exerciseSchemas.updateExercise,
    preHandler: [fastify.authenticate, fastify.requireAdmin],
    handler: async (request: FastifyRequest<{
      Params: { id: string };
      Body: Partial<{
        titre: string;
        consigne: string;
        type: string;
        difficulte: string;
        configuration: Record<string, any>;
        pointsReussite: number;
        dureeEstimee: number;
        ordre: number;
        actif: boolean;
      }>;
    }>, reply: FastifyReply) => {
      try {
        const exerciseId = parseInt(request.params.id);
        const updateData = request.body;

        // Add update metadata
        const metadata = {
          lastModifiedBy: request.user.id,
          lastModifiedAt: new Date().toISOString()
        };

        await fastify.db
          .update(exercises)
          .set({ 
            ...updateData, 
            metadata: { ...metadata },
            updatedAt: new Date() 
          })
          .where(eq(exercises.id, exerciseId));

        // Clear caches
        await fastify.cache.del([
          'exercises:*',
          'recommendations:*',
          `exercise:${exerciseId}:*`
        ]);

        return reply.send({
          success: true,
          message: 'Exercice mis à jour avec succès'
        });

      } catch (error) {
        fastify.log.error('Update exercise error:', error);
        return reply.status(500).send({
          success: false,
          error: {
            message: 'Erreur lors de la mise à jour',
            code: 'UPDATE_EXERCISE_ERROR'
          }
        });
      }
    }
  });

  // Delete exercise
  fastify.delete('/:id', {
    schema: exerciseSchemas.deleteExercise,
    preHandler: [fastify.authenticate, fastify.requireAdmin],
    handler: async (request: FastifyRequest<{
      Params: { id: string };
    }>, reply: FastifyReply) => {
      try {
        const exerciseId = parseInt(request.params.id);

        await fastify.db
          .delete(exercises)
          .where(eq(exercises.id, exerciseId));

        // Clear caches
        await fastify.cache.del([
          'exercises:*',
          'recommendations:*',
          `exercise:${exerciseId}:*`
        ]);

        return reply.send({
          success: true,
          message: 'Exercice supprimé avec succès'
        });

      } catch (error) {
        fastify.log.error('Delete exercise error:', error);
        return reply.status(500).send({
          success: false,
          error: {
            message: 'Erreur lors de la suppression',
            code: 'DELETE_EXERCISE_ERROR'
          }
        });
      }
    }
  });
};

// ==========================================
// HELPER FUNCTIONS
// ==========================================

async function validateExerciseConfiguration(
  type: string, 
  configuration: Record<string, any>
): Promise<Record<string, any>> {
  // Type-specific validation logic
  switch (type) {
    case 'QCM':
      if (!configuration.question || !configuration.choix || !configuration.bonneReponse) {
        throw new Error('QCM requires question, choix, and bonneReponse');
      }
      break;
    case 'CALCUL':
      if (!configuration.operation || !configuration.resultat) {
        throw new Error('CALCUL requires operation and resultat');
      }
      break;
    case 'DRAG_DROP':
      if (!configuration.items || !configuration.zones) {
        throw new Error('DRAG_DROP requires items and zones');
      }
      break;
    case 'LECTURE':
      if (!configuration.texte || !configuration.questions) {
        throw new Error('LECTURE requires texte and questions');
      }
      break;
    // Add more validations as needed
  }
  
  return configuration;
}

async function generateExercisesForCompetence(
  competenceCode: string,
  baseConfig: Record<string, any>,
  generateVariations: boolean
): Promise<Array<{
  titre: string;
  consigne: string;
  type: string;
  difficulte: string;
  configuration: Record<string, any>;
  pointsReussite: number;
  dureeEstimee: number;
  ordre: number;
}>> {
  // Parse competence code: CP.FR.L1.1
  const [niveau, matiere, domaine, competence] = competenceCode.split('.');
  
  // CP 2025 competence mapping
  const exerciseTemplates = [];
  
  if (matiere === 'FR') {
    if (domaine.startsWith('L')) {
      // Lecture competences
      exerciseTemplates.push(...generateReadingExercises(competenceCode, baseConfig));
    } else if (domaine.startsWith('E')) {
      // Écriture competences  
      exerciseTemplates.push(...generateWritingExercises(competenceCode, baseConfig));
    } else if (domaine.startsWith('C')) {
      // Compréhension competences
      exerciseTemplates.push(...generateComprehensionExercises(competenceCode, baseConfig));
    }
  } else if (matiere === 'MA') {
    if (domaine.startsWith('N')) {
      // Nombres competences
      exerciseTemplates.push(...generateNumberExercises(competenceCode, baseConfig));
    } else if (domaine.startsWith('P')) {
      // Problèmes competences
      exerciseTemplates.push(...generateProblemExercises(competenceCode, baseConfig));
    } else if (domaine.startsWith('G')) {
      // Géométrie competences
      exerciseTemplates.push(...generateGeometryExercises(competenceCode, baseConfig));
    }
  }
  
  // Generate variations if requested
  if (generateVariations && exerciseTemplates.length > 0) {
    const variations = [];
    for (const template of exerciseTemplates) {
      // Create 2-3 variations per template
      for (let i = 1; i <= 3; i++) {
        variations.push({
          ...template,
          titre: `${template.titre} (Variante ${i})`,
          ordre: template.ordre + i - 1
        });
      }
    }
    return variations;
  }
  
  return exerciseTemplates;
}

function generateReadingExercises(competenceCode: string, baseConfig: any) {
  // Implementation for reading exercises based on CP.FR.L codes
  const templates = [];
  
  if (competenceCode.includes('L1')) {
    // Correspondances Graphème-Phonème
    templates.push({
      titre: 'Reconnaissance des sons',
      consigne: 'Identifie le son que tu entends dans le mot',
      type: 'QCM',
      difficulte: 'decouverte',
      configuration: {
        question: 'Quel son entends-tu dans "CHAT" ?',
        choix: ['CH', 'CA', 'AT', 'HA'],
        bonneReponse: 'CH',
        targetSound: 'ch'
      },
      pointsReussite: 10,
      dureeEstimee: 3,
      ordre: 1
    });
  }
  
  // Add more reading exercise templates...
  return templates;
}

function generateNumberExercises(competenceCode: string, baseConfig: any) {
  // Implementation for math number exercises based on CP.MA.N codes
  const templates = [];
  
  if (competenceCode.includes('N1')) {
    // Construction du Nombre
    templates.push({
      titre: 'Compter jusqu\'à 10',
      consigne: 'Compte les objets et écris le nombre',
      type: 'CALCUL',
      difficulte: 'decouverte',
      configuration: {
        question: 'Combien d\'objets vois-tu ?',
        imageUrl: '/images/count-objects-5.png',
        resultat: 5,
        range: [1, 10]
      },
      pointsReussite: 10,
      dureeEstimee: 5,
      ordre: 1
    });
  }
  
  // Add more number exercise templates...
  return templates;
}

// Add more helper functions for other competence types...
function generateWritingExercises(competenceCode: string, baseConfig: any) { return []; }
function generateComprehensionExercises(competenceCode: string, baseConfig: any) { return []; }
function generateProblemExercises(competenceCode: string, baseConfig: any) { return []; }
function generateGeometryExercises(competenceCode: string, baseConfig: any) { return []; }

export default exercisesRoutes; 