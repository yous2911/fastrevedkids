import { competenceReference } from '../data/cp2025-competences';

interface ExerciseTemplate {
  titre: string;
  consigne: string;
  type: string;
  difficulte: string;
  configuration: Record<string, any>;
  pointsReussite: number;
  dureeEstimee: number;
  ordre: number;
  metadata: Record<string, any>;
}

export class CP2025Service {
  
  // Validate competence code format and existence
  static validateCompetenceCode(code: string): boolean {
    const regex = /^(CP|CE1|CE2|CM1|CM2)\.(FR|MA)\.[A-Z]+\d+\.\d+$/;
    if (!regex.test(code)) return false;
    
    // Check if competence exists in reference
    return competenceReference.hasOwnProperty(code);
  }
  
  // Get competence details from code
  static getCompetenceDetails(code: string) {
    return competenceReference[code] || null;
  }
  
  // Generate exercise template based on competence
  static generateExerciseTemplate(competenceCode: string): ExerciseTemplate | null {
    const details = this.getCompetenceDetails(competenceCode);
    if (!details) return null;
    
    const [niveau, matiere, domaine, competence] = competenceCode.split('.');
    
    // Base template
    const template: ExerciseTemplate = {
      titre: details.titre,
      consigne: details.consigne || `Exercice sur ${details.titre}`,
      type: this.determineExerciseType(domaine, details),
      difficulte: this.determineDifficulty(competence, details),
      configuration: this.generateConfiguration(competenceCode, details),
      pointsReussite: this.calculatePoints(domaine, competence),
      dureeEstimee: this.estimateDuration(domaine, details),
      ordre: parseInt(competence.slice(-1)) || 1,
      metadata: {
        competenceCode,
        cp2025Domain: domaine,
        autoGenerated: true,
        generatedAt: new Date().toISOString()
      }
    };
    
    return template;
  }
  
  // Determine exercise type based on domain and competence
  private static determineExerciseType(domaine: string, details: any): string {
    // Français - Lecture
    if (domaine.startsWith('L')) {
      if (domaine.includes('1')) return 'QCM'; // CGP
      if (domaine.includes('2')) return 'DRAG_DROP'; // Syllabation
      if (domaine.includes('3')) return 'LECTURE'; // Fluence
    }
    
    // Français - Écriture
    if (domaine.startsWith('E')) {
      if (domaine.includes('1')) return 'TEXTE_LIBRE'; // Calligraphie
      if (domaine.includes('2')) return 'TEXTE_LIBRE'; // Orthographe
      if (domaine.includes('3')) return 'TEXTE_LIBRE'; // Production
    }
    
    // Français - Compréhension
    if (domaine.startsWith('C')) {
      return 'QCM'; // Questions de compréhension
    }
    
    // Français - Grammaire
    if (domaine.startsWith('G')) {
      return 'DRAG_DROP'; // Classification, accords
    }
    
    // Mathématiques - Nombres
    if (domaine.startsWith('N')) {
      return 'CALCUL'; // Nombres et calculs
    }
    
    // Mathématiques - Problèmes
    if (domaine.startsWith('P')) {
      return 'PROBLEME'; // Résolution de problèmes
    }
    
    // Mathématiques - Géométrie
    if (domaine.startsWith('G')) {
      return 'GEOMETRIE'; // Formes et constructions
    }
    
    // Mathématiques - Mesures
    if (domaine.startsWith('M')) {
      return 'QCM'; // Comparaisons et mesures
    }
    
    return 'QCM'; // Default
  }
  
  // Determine difficulty progression
  private static determineDifficulty(competence: string, details: any): string {
    const competenceNum = parseInt(competence.slice(-1));
    
    if (competenceNum <= 2) return 'decouverte';
    if (competenceNum <= 4) return 'entrainement';
    if (competenceNum <= 6) return 'consolidation';
    return 'approfondissement';
  }
  
  // Generate exercise configuration
  private static generateConfiguration(competenceCode: string, details: any): Record<string, any> {
    const [niveau, matiere, domaine, competence] = competenceCode.split('.');
    
    // Français - Lecture CGP
    if (competenceCode.includes('FR.L1')) {
      return {
        question: "Quel son entends-tu dans ce mot ?",
        type: "sound_recognition",
        targetSounds: this.getTargetSounds(competence),
        choix: this.generateSoundChoices(competence),
        bonneReponse: 0, // First choice is correct
        audioRequired: true
      };
    }
    
    // Français - Lecture Syllabation
    if (competenceCode.includes('FR.L2')) {
      return {
        question: "Décompose ce mot en syllabes",
        type: "syllable_segmentation",
        targetWord: this.getTargetWord(competence),
        expectedSyllables: this.getSyllables(competence),
        dragItems: this.generateSyllableDragItems(competence),
        zones: [{ id: "syllable-zone", label: "Glisse les syllabes ici" }]
      };
    }
    
    // Français - Lecture Fluence
    if (competenceCode.includes('FR.L3')) {
      return {
        question: "Lis ce texte à voix haute",
        type: "reading_fluency",
        texte: this.getReadingText(competence),
        mots_cibles: this.getTargetWords(competence),
        temps_limite: this.getTimeLimit(competence),
        recording_required: true
      };
    }
    
    // Mathématiques - Nombres
    if (competenceCode.includes('MA.N1')) {
      return {
        question: "Compte les objets et écris le nombre",
        type: "number_recognition",
        range: this.getNumberRange(competence),
        objectCount: this.getObjectCount(competence),
        imageUrl: `/images/count-objects-${this.getObjectCount(competence)}.png`,
        acceptedAnswers: [this.getObjectCount(competence)]
      };
    }
    
    // Mathématiques - Calcul Mental
    if (competenceCode.includes('MA.N3')) {
      return {
        question: "Calcule rapidement",
        type: "mental_calculation",
        operation: this.generateOperation(competence),
        operandes: this.getOperands(competence),
        resultat: this.calculateResult(competence),
        temps_limite: 30 // 30 secondes
      };
    }
    
    // Mathématiques - Problèmes
    if (competenceCode.includes('MA.P')) {
      return {
        question: this.getProblemStatement(competence),
        type: "word_problem",
        donnees: this.getProblemData(competence),
        operation_attendue: this.getExpectedOperation(competence),
        resultat: this.getProblemResult(competence),
        aide_disponible: true
      };
    }
    
    // Default configuration
    return {
      question: details.titre,
      type: "generic",
      aide: "Lis bien la consigne avant de commencer."
    };
  }
  
  // Helper methods for specific competences
  private static getTargetSounds(competence: string): string[] {
    const soundMappings = {
      '1': ['a', 'i', 'o', 'u', 'e'],
      '2': ['m', 'n', 'p', 't', 'r'],
      '3': ['ch', 'ou', 'an', 'in', 'on'],
      '4': ['eau', 'tion', 'ph', 'gn'],
      '5': ['ail', 'euil', 'oe', 'oeu']
    };
    return soundMappings[competence.slice(-1)] || ['a'];
  }
  
  private static generateSoundChoices(competence: string): string[] {
    const sounds = this.getTargetSounds(competence);
    const distractors = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l'];
    return [sounds[0], ...distractors.slice(0, 3)];
  }
  
  private static getNumberRange(competence: string): [number, number] {
    const rangeMappings = {
      '1': [0, 10],
      '2': [11, 20],
      '3': [21, 59],
      '4': [60, 100],
      '5': [0, 100]
    };
    return rangeMappings[competence.slice(-1)] || [0, 10];
  }
  
  private static getObjectCount(competence: string): number {
    const [min, max] = this.getNumberRange(competence);
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  
  private static generateOperation(competence: string): string {
    const operations = {
      '1': ['+'],
      '2': ['+', '-'],
      '3': ['+', '-'],
      '4': ['×', '÷'],
      '5': ['+', '-', '×']
    };
    const ops = operations[competence.slice(-1)] || ['+'];
    return ops[Math.floor(Math.random() * ops.length)];
  }
  
  private static getOperands(competence: string): number[] {
    const [min, max] = this.getNumberRange(competence);
    const a = Math.floor(Math.random() * max) + 1;
    const b = Math.floor(Math.random() * max) + 1;
    return [a, b];
  }
  
  private static calculateResult(competence: string): number {
    const operands = this.getOperands(competence);
    const operation = this.generateOperation(competence);
    
    switch (operation) {
      case '+': return operands[0] + operands[1];
      case '-': return Math.abs(operands[0] - operands[1]);
      case '×': return operands[0] * operands[1];
      case '÷': return Math.floor(operands[0] / operands[1]);
      default: return operands[0] + operands[1];
    }
  }
  
  private static calculatePoints(domaine: string, competence: string): number {
    const basePoints = 10;
    const competenceLevel = parseInt(competence.slice(-1)) || 1;
    
    // More points for advanced competences
    return basePoints + (competenceLevel - 1) * 2;
  }
  
  private static estimateDuration(domaine: string, details: any): number {
    // Duration in minutes based on exercise type
    const durationMappings = {
      'L': 5,  // Lecture: 5 min
      'E': 10, // Écriture: 10 min
      'C': 7,  // Compréhension: 7 min
      'G': 6,  // Grammaire: 6 min
      'N': 4,  // Nombres: 4 min
      'P': 8,  // Problèmes: 8 min
      'M': 5   // Mesures: 5 min
    };
    
    return durationMappings[domaine.charAt(0)] || 5;
  }
  
  // Additional helper methods
  private static getTargetWord(competence: string): string {
    const words = ['chat', 'maison', 'soleil', 'jardin', 'école'];
    return words[parseInt(competence.slice(-1)) % words.length];
  }
  
  private static getSyllables(competence: string): string[] {
    const word = this.getTargetWord(competence);
    const syllableMap = {
      'chat': ['chat'],
      'maison': ['mai', 'son'],
      'soleil': ['so', 'leil'],
      'jardin': ['jar', 'din'],
      'école': ['é', 'cole']
    };
    return syllableMap[word] || [word];
  }
  
  private static generateSyllableDragItems(competence: string): Array<{id: string, content: string}> {
    const syllables = this.getSyllables(competence);
    const distractors = ['ba', 'to', 'lu', 'mi'];
    
    return [
      ...syllables.map((syl, i) => ({ id: `correct-${i}`, content: syl })),
      ...distractors.slice(0, 2).map((syl, i) => ({ id: `distractor-${i}`, content: syl }))
    ];
  }
  
  private static getReadingText(competence: string): string {
    const texts = {
      '1': "Le chat mange.",
      '2': "Marie va à l'école avec son sac.",
      '3': "Dans le jardin, les fleurs sont belles et colorées.",
      '4': "Aujourd'hui, nous allons découvrir une histoire passionnante qui se déroule dans une forêt magique."
    };
    return texts[competence.slice(-1)] || texts['1'];
  }
  
  private static getTargetWords(competence: string): string[] {
    const text = this.getReadingText(competence);
    return text.split(' ').filter(word => word.length > 2);
  }
  
  private static getTimeLimit(competence: string): number {
    const limits = { '1': 30, '2': 45, '3': 60, '4': 90 };
    return limits[competence.slice(-1)] || 30;
  }
  
  private static getProblemStatement(competence: string): string {
    const problems = {
      '1': "Paul a 3 billes. Il en gagne 2 de plus. Combien a-t-il de billes maintenant ?",
      '2': "Dans la classe, il y a 12 élèves. 5 élèves sortent en récréation. Combien d'élèves restent dans la classe ?",
      '3': "Marie range ses 24 crayons dans des boîtes de 6. Combien de boîtes lui faut-il ?",
      '4': "Un bouquet coûte 8 euros. Combien coûtent 3 bouquets ?"
    };
    return problems[competence.slice(-1)] || problems['1'];
  }
  
  private static getProblemData(competence: string): Record<string, any> {
    const dataMap = {
      '1': { initial: 3, added: 2 },
      '2': { total: 12, removed: 5 },
      '3': { total: 24, perBox: 6 },
      '4': { price: 8, quantity: 3 }
    };
    return dataMap[competence.slice(-1)] || dataMap['1'];
  }
  
  private static getExpectedOperation(competence: string): string {
    const operations = { '1': '+', '2': '-', '3': '÷', '4': '×' };
    return operations[competence.slice(-1)] || '+';
  }
  
  private static getProblemResult(competence: string): number {
    const data = this.getProblemData(competence);
    const operation = this.getExpectedOperation(competence);
    
    switch (competence.slice(-1)) {
      case '1': return data.initial + data.added;
      case '2': return data.total - data.removed;
      case '3': return data.total / data.perBox;
      case '4': return data.price * data.quantity;
      default: return 5;
    }
  }
} 