/**
 * RevEd Kids Frontend Service Worker
 * Provides offline functionality, caching strategies, and PWA features
 */

/* eslint-disable no-restricted-globals */

import { precacheAndRoute, cleanupOutdatedCaches, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst, NetworkOnly } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { ExpirationPlugin } from 'workbox-expiration';
import { BackgroundSyncPlugin } from 'workbox-background-sync';
import { Queue } from 'workbox-background-sync';

const CACHE_PREFIX = 'reved-kids';
const CACHE_VERSION = 'v1.0.0';
const API_CACHE_NAME = `${CACHE_PREFIX}-api-${CACHE_VERSION}`;
const STATIC_CACHE_NAME = `${CACHE_PREFIX}-static-${CACHE_VERSION}`;
const RUNTIME_CACHE_NAME = `${CACHE_PREFIX}-runtime-${CACHE_VERSION}`;
const IMAGE_CACHE_NAME = `${CACHE_PREFIX}-images-${CACHE_VERSION}`;
const AUDIO_CACHE_NAME = `${CACHE_PREFIX}-audio-${CACHE_VERSION}`;
const THREE_CACHE_NAME = `${CACHE_PREFIX}-three-${CACHE_VERSION}`;

// Precache all of the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Clean up any previous precache
cleanupOutdatedCaches();

// Handle navigation requests
const navigationHandler = createHandlerBoundToURL('/index.html');
const navigationRoute = new NavigationRoute(navigationHandler, {
  denylist: [/^\/_/, /\/[^/?]+\.[^/]+$/],
});
registerRoute(navigationRoute);

// Cache strategies for different resource types

// 1. API Routes - Network First with background sync fallback
const bgSyncPlugin = new BackgroundSyncPlugin('api-queue', {
  maxRetentionTime: 24 * 60, // Retry for max of 24 Hours (in minutes)
});

registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: API_CACHE_NAME,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 60, // 30 minutes
      }),
      bgSyncPlugin,
    ],
  })
);

// 2. Static JavaScript and CSS - Cache First
registerRoute(
  ({ request }) =>
    request.destination === 'script' ||
    request.destination === 'style',
  new CacheFirst({
    cacheName: STATIC_CACHE_NAME,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// 3. Images - Cache First with WebP preference
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: IMAGE_CACHE_NAME,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// 4. Audio files - Cache First for better performance
registerRoute(
  ({ request }) =>
    request.destination === 'audio' ||
    request.url.includes('/sounds/'),
  new CacheFirst({
    cacheName: AUDIO_CACHE_NAME,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// 5. Three.js assets and 3D models - Cache First
registerRoute(
  ({ url }) =>
    url.pathname.includes('/models/') ||
    url.pathname.includes('/textures/') ||
    url.pathname.endsWith('.gltf') ||
    url.pathname.endsWith('.glb') ||
    url.pathname.endsWith('.fbx'),
  new CacheFirst({
    cacheName: THREE_CACHE_NAME,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// 6. Fonts - Cache First
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: `${CACHE_PREFIX}-fonts-${CACHE_VERSION}`,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
      }),
    ],
  })
);

// 7. Google Fonts - Stale While Revalidate
registerRoute(
  ({ url }) =>
    url.origin === 'https://fonts.googleapis.com' ||
    url.origin === 'https://fonts.gstatic.com',
  new StaleWhileRevalidate({
    cacheName: `${CACHE_PREFIX}-google-fonts-${CACHE_VERSION}`,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
      }),
    ],
  })
);

// Background Sync for offline actions
const analyticsQueue = new Queue('analytics-queue', {
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request);
        console.log('Analytics data synced successfully');
      } catch (error) {
        console.error('Failed to sync analytics data:', error);
        // Re-add to queue for retry
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  },
});

// Handle offline analytics
self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('/api/analytics')) {
    if (!navigator.onLine) {
      event.waitUntil(analyticsQueue.pushRequest({ request: event.request }));
    }
  }
});

// PWA Installation prompt
let deferredPrompt;

self.addEventListener('beforeinstallprompt', (e) => {
  console.log('PWA install prompt available');
  e.preventDefault();
  deferredPrompt = e;
  
  // Notify the main thread that install is available
  self.clients.matchAll().then((clients) => {
    clients.forEach((client) => {
      client.postMessage({
        type: 'PWA_INSTALL_AVAILABLE',
        canInstall: true,
      });
    });
  });
});

// Handle PWA installation
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'PWA_INSTALL_TRIGGER') {
    if (deferredPrompt) {
      deferredPrompt.prompt();
      deferredPrompt.userChoice.then((choiceResult) => {
        console.log('PWA install choice:', choiceResult.outcome);
        deferredPrompt = null;
      });
    }
  }
});

// Handle app installation
self.addEventListener('appinstalled', (event) => {
  console.log('PWA was installed');
  // Send analytics event
  self.clients.matchAll().then((clients) => {
    clients.forEach((client) => {
      client.postMessage({
        type: 'PWA_INSTALLED',
        installed: true,
      });
    });
  });
});

// Performance monitoring
self.addEventListener('activate', (event) => {
  console.log('Service Worker activated');
  
  // Measure cache performance
  event.waitUntil(
    (async () => {
      const cacheNames = await caches.keys();
      const totalCacheSize = await Promise.all(
        cacheNames.map(async (cacheName) => {
          const cache = await caches.open(cacheName);
          const requests = await cache.keys();
          let size = 0;
          
          for (const request of requests) {
            const response = await cache.match(request);
            if (response) {
              const blob = await response.blob();
              size += blob.size;
            }
          }
          return size;
        })
      );
      
      const totalSize = totalCacheSize.reduce((sum, size) => sum + size, 0);
      console.log(`Total cache size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);
    })()
  );
});

// Handle fetch events for offline functionality
self.addEventListener('fetch', (event) => {
  // Skip non-GET requests
  if (event.request.method !== 'GET') {
    return;
  }

  // Handle educational content offline
  if (event.request.url.includes('/exercises/') || 
      event.request.url.includes('/lessons/')) {
    event.respondWith(
      caches.match(event.request).then((cachedResponse) => {
        if (cachedResponse) {
          return cachedResponse;
        }
        
        return fetch(event.request)
          .then((response) => {
            // Cache successful responses
            if (response.status === 200) {
              const responseClone = response.clone();
              caches.open(RUNTIME_CACHE_NAME).then((cache) => {
                cache.put(event.request, responseClone);
              });
            }
            return response;
          })
          .catch(() => {
            // Return offline fallback
            return new Response(
              JSON.stringify({
                error: 'Content not available offline',
                offline: true,
                timestamp: Date.now(),
              }),
              {
                headers: { 'Content-Type': 'application/json' },
                status: 503,
              }
            );
          });
      })
    );
  }
});

// Cleanup old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName.startsWith(CACHE_PREFIX) && 
              !cacheName.includes(CACHE_VERSION)) {
            console.log('Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// Network status monitoring
self.addEventListener('online', () => {
  console.log('App is back online');
  self.clients.matchAll().then((clients) => {
    clients.forEach((client) => {
      client.postMessage({
        type: 'NETWORK_STATUS_CHANGE',
        online: true,
      });
    });
  });
});

self.addEventListener('offline', () => {
  console.log('App is now offline');
  self.clients.matchAll().then((clients) => {
    clients.forEach((client) => {
      client.postMessage({
        type: 'NETWORK_STATUS_CHANGE',
        online: false,
      });
    });
  });
});

// Skip waiting and claim clients immediately
self.addEventListener('install', (event) => {
  console.log('Service Worker installing');
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  console.log('Service Worker activating');
  event.waitUntil(self.clients.claim());
});